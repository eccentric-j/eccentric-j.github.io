<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Eccentric J</title><subtitle>Eccentric J's blog on Functional Programming, Clojure, and Engineering</subtitle><generator uri="https://perun.io/" version="0.4.2-SNAPSHOT">Perun</generator><link href="https://eccentric-j.com/" type="text/html"></link><link href="https://eccentric-j.com/atom.xml" rel="self"></link><link href="https://eccentric-j.com/atom.xml" rel="first"></link><link href="https://eccentric-j.com/atom.xml" rel="last"></link><updated>2019-02-01T05:46:27Z</updated><id>https://eccentric-j.com/</id><entry><id>urn:uuid:e46eaeb3-d5d5-4fc8-ba4d-de37cf869a07</id><title>How do you finish big side projects?</title><link href="https://eccentric-j.com/blog/4-completing-side-projects-in-2019.html" type="text/html" title="How do you finish big side projects?" rel="alternate"></link><published>2019-02-01T05:27:00Z</published><updated>2019-02-01T05:43:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/4-completing-side-projects-in-2019.html">&lt;h1&gt;&lt;a href="#2018-in-review" id="2018-in-review"&gt;&lt;/a&gt;2018 in Review&lt;/h1&gt;
&lt;p&gt;Every year since discovering &lt;a href="https://www.pinterest.com/bulletjournal/"&gt;bullet journaling&lt;/a&gt; I like to reflect on how I spent my time. In 2018 there has been noticeable improvement: I&amp;rsquo;ve been sleeping more, working closer to 40 hours a week, and more consistency with my schedule. There is however one major problem: I did not complete a single major side project!&lt;/p&gt;
&lt;h2&gt;&lt;a href="#how-did-i-not-complete-a-single-major-side-project-in-2018" id="how-did-i-not-complete-a-single-major-side-project-in-2018"&gt;&lt;/a&gt;How did I not complete a single major side project in 2018?&lt;/h2&gt;
&lt;p&gt;It comes down to my work habits. Looking at my how I spent my time I have two modes: Sprinting towards a finish line at a ridiculous pace or sloth mode, criminally chilling between projects. I did finish some smaller side projects, ones that could be sprinted through in a few late nights and a weekend. The problem appears to be a cycle I&amp;rsquo;ve created: Sprint through a small project, sloth it up until I recover and move on to the next project to start the cycle again. Now how do I fix it?&lt;/p&gt;
&lt;h2&gt;&lt;a href="#how-do-you-manage-your-time-for-side-projects" id="how-do-you-manage-your-time-for-side-projects"&gt;&lt;/a&gt;How do you manage your time for side projects?&lt;/h2&gt;
&lt;p&gt;In researching a few articles, books, and a bit of discussion there are some simple steps to make 2019 the year of the side project:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Break down your projects into the tiniest goals. If you know a project is going to take months: compose it down into 20 minute tasks. Working on a month long project is terrifying; working on a small task for 20 minutes sounds like a good way to start or end the day.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Be consistent when you work on side projects. It’s much easier to plan your day when you know 10:30 to 11 am is your side project time.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Try to work a little bit on a side project many days in a row. Once the habit forms, it feels weird not to spend mornings on a side project. Once you stop it feels weird to resume working on a side project.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don&amp;rsquo;t sprint and exhaust yourself. Instead try working on side projects a little bit at a time from 20 minutes to an hour and half. That way you can keep the pace up for longer stretches of time without burning out or loosing interest.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ensure you are taking time for yourself or having designated time that can’t be spent on side projects. I have the tendency to get really into a project and missing out on sleep, eating, and relaxation to try and sprint through it until completion. I&amp;rsquo;m basically begging for death, while metal as fuck &#x1f918;, that is not really how I want to go out.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Accept the outcome and let it go. This is where I shoot myself in the foot the most, when the 20 minute timer comes up and I impulsively start the timer immediately again telling myself &amp;ldquo;I&amp;rsquo;ll be able to finish it this time.&amp;rdquo; Then again. Then again and oh look, 3 hours just passed by. The gym is closed, the heat at the office has been shut off, and I haven&amp;rsquo;t eaten for 6 hours. Instead you need to retrain your mind to accept the result, whether the task is finished or not you made progress. Do something else and come back to it at the appropriate time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="#does-this-advice-actually-work" id="does-this-advice-actually-work"&gt;&lt;/a&gt;Does this advice actually work?&lt;/h2&gt;
&lt;p&gt;This blog is the proof that applying those practices did help me complete at least one project this year. I wasn&amp;rsquo;t perfect, there have been stretches where I overdid it but it was still more sustainable than any other project I tried to work on in 2018. Other project ideas even came up while working on this blog but I did my best to write them down so I can return to them later. I imagine with more practice using the above strategy I may improve further. Still though how do you stop when you are enjoying yourself the most?&lt;/p&gt;
&lt;h2&gt;&lt;a href="#how-do-you-stop-when-you-want-to-keep-going" id="how-do-you-stop-when-you-want-to-keep-going"&gt;&lt;/a&gt;How do you stop when you want to keep going?&lt;/h2&gt;
&lt;p&gt;My biggest issue is stopping myself when those 20 minutes are up. There were parts of this blog I really enjoyed working on and felt compelled to see features through so I kept working on them. The consequences of doing so are fairly minor but they will add up. It almost physically hurts to stop working on a task that seems reachable within a few minutes to an hour, I think there&amp;rsquo;s some latent fear that I will not be able to solve it later even though historically I do. I don&amp;rsquo;t have a great solution for this yet but after asking the community in the Clojure slack I got some good advice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Set a physical alarm somewhere you have to get up and stop. This way you can&amp;rsquo;t just keep working, you have to physically move to turn it off.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reward yourself for being disciplined. Go ahead, put in your 20 min then get a fancy hipster coffee. You earned it!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Switch gears to a more enjoyable activity. If your problem is that you are &amp;ldquo;hooked on fun&amp;rdquo; (as it was put in the channel) then watch a movie, play a game, go on a date, eat, it just has to be something you will enjoy more.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When the timer is up, make sure you take a break or switch tasks. Treat it as an equally important part of the process as the task itself.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course I accidentally thought up of another side project in the form of a CLI tool that closes a tmux environment or other shell command after a time limit (likely killing any running development REPLs and servers). It still needs fleshing out but check out the wireframes:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://app.moqups.com/jayzawrotny/xG7CCH79a4/view"&gt;&lt;img src="/img/blog/4-side-project.png" alt="Side Project Wireframe" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#whats-next" id="whats-next"&gt;&lt;/a&gt;What&amp;rsquo;s next?&lt;/h2&gt;
&lt;p&gt;If you&amp;rsquo;re like me, we simply need to practice discipline. After more than a decade of working like this on personal projects I need to really put some time and effort into breaking those habits. There are three ways I&amp;rsquo;m going to approach this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Read books on building habits and discipline. Learning how to influence the brain’s decision making and reactions to stimuli will be very valuable in figuring out a more actionable plan.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Practice using the advice above to develop a better sense of pace and consistency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Track side project time in my bullet journal so I can observe improvements or patterns&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="experience"></category><category term="year-review"></category></entry><entry><id>urn:uuid:db151ec4-50b8-42f9-b20e-2153cb5d93f2</id><title>My Functional Programming Experience</title><link href="https://eccentric-j.com/blog/3-functional-programming-experience.html" type="text/html" title="My Functional Programming Experience" rel="alternate"></link><published>2019-01-29T00:31:00Z</published><updated>2019-01-29T18:52:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/3-functional-programming-experience.html">&lt;h1&gt;&lt;a href="#discovering-functional-programming" id="discovering-functional-programming"&gt;&lt;/a&gt;Discovering Functional Programming&lt;/h1&gt;
&lt;p&gt;I first encountered the phrase &amp;ldquo;Functional Programming&amp;rdquo; when learning about Redux for JS. My first question was &amp;ldquo;Isn’t all programming functional?&amp;rdquo; then I began researching it and got genuinely curious and found the motivation to study it further. Now about 2 years into it I can confirm it has deeply impacted how I think, work, and the trajectory of my career.&lt;/p&gt;
&lt;p&gt;When I started learning I was really in the weeds with OOP and wanted to abstract, generalize, and use all those fancy OOP patterns everywhere it made sense. The problem is whenever you create a custom class in most languages, it’s incompatible with everything else. Even in JS if I extend an array class it’s often treated as a separate type. So you often have to write more classes to make two classes talk to each other.&lt;/p&gt;
&lt;p&gt;In addition to those layers of abstraction for OOP I think there’s no upper limit to the complexity you can achieve and the vocabulary to describe OOP systems. Getters, setters, public, private, accessors, attributes, methods, virtual properties, constructor overrides, generics, magic methods, over loading, dependency injections, super, child,  inheritance, the list goes on I’m sure.&lt;/p&gt;
&lt;p&gt;With functional programming I find it has a pretty fixed amount of concepts that make up the methodology:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immutability&lt;/li&gt;
&lt;li&gt;Pure Functions&lt;/li&gt;
&lt;li&gt;Referential Transparency&lt;/li&gt;
&lt;li&gt;Composition&lt;/li&gt;
&lt;li&gt;Higher Order Functions&lt;/li&gt;
&lt;li&gt;Core Data Types&lt;/li&gt;
&lt;li&gt;Functors&lt;/li&gt;
&lt;li&gt;Monads&lt;/li&gt;
&lt;li&gt;Point Free&lt;/li&gt;
&lt;li&gt;Predicates&lt;/li&gt;
&lt;li&gt;Map, Filter, Reduce functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That may not be every concept but it is more than enough to build a strong sense of competency with the methodology.&lt;/p&gt;
&lt;p&gt;What’s great about learning those is that they all build on each other where as a lot of those OOP concepts are kind of parallel to each other where you can learn one without knowing the other.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#types-of-functional-programming-languages" id="types-of-functional-programming-languages"&gt;&lt;/a&gt;Types of Functional Programming Languages&lt;/h2&gt;
&lt;p&gt;There’s two major camps that functional programming falls into:&lt;/p&gt;
&lt;h3&gt;&lt;a href="#dynamic-languages" id="dynamic-languages"&gt;&lt;/a&gt;Dynamic Languages&lt;/h3&gt;
&lt;p&gt;Languages like Elixir and Clojure fall into this camp. They leverage dynamic types and focus on creating pipelines of functions to transform data. These languages also tend to be more side-effect friendly with looser restrictions but agreed upon naming conventions to denote when side effects happen. Generally these languages have a more practical nature to them focusing on getting work done.&lt;/p&gt;
&lt;h3&gt;&lt;a href="#static-languages" id="static-languages"&gt;&lt;/a&gt;Static Languages&lt;/h3&gt;
&lt;p&gt;Languages like Elm, F#, OCaml or Haskell fall into this camp. They emphasize type theory and other mathematic principles to leverage monads, or data types that represent computation builders to do most of the work. For instance the Array type in JS is a monad, it can be mapped to an array of other values, packed, and unpacked in itself. These languages are more strict about side effects often requiring them to be wrapped in a IO monad or similar system to separate out side-effect work from pure functions. While they can be used for practical work they often have an academic background and require more specification in determining the correctness of a program. For instance your program might not compile until you specify which types a function receives and returns.&lt;/p&gt;
&lt;h4&gt;&lt;a href="#other-languages" id="other-languages"&gt;&lt;/a&gt;Other Languages&lt;/h4&gt;
&lt;p&gt;Languages like JS, Ruby, and Python have some functional capabilities but I don’t consider them functional programming languages for the sake of this discussion. You can of course apply functional programming concepts to or within these languages.&lt;/p&gt;
&lt;h4&gt;&lt;a href="#comparison" id="comparison"&gt;&lt;/a&gt;Comparison&lt;/h4&gt;
&lt;p&gt;In so far I don’t strongly feel one camp is better than another, I’ve just noticed that functional programming languages tend to lean to one side more than the other. While I’ve chosen to focus on Clojure and Elixir for now, I’m also interested in learning and hearing about Haskell and Elm.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#does-functional-programming-make-you-a-better-programmer" id="does-functional-programming-make-you-a-better-programmer"&gt;&lt;/a&gt;Does functional programming make you a better programmer?&lt;/h2&gt;
&lt;p&gt;As far as improving as a programmer and engineer: I think putting in the time and effort to learning it will impact you for the better. I’ve learned how to reduce complexity in the work I produce by composing larger systems from smaller functions that have very specific jobs, often aimed at expressing a domain-specific goal with pure functions as much as possible. This means fewer surprises for other programmers and stronger testability because testing pure functions like &lt;code&gt;add(1, 2)&lt;/code&gt; is much easier than testing classes, instances, and runtime app state like &lt;code&gt;this.router.handleRoute(window.location)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Instead of trying to make more complex data types like I did when strictly using OOP, I find myself mostly leaning on core types. Elixir is a great example; Elixir has hundreds of functions that can work on lists, maps, streams, and files. It has zero that work on that &lt;code&gt;Bid&lt;/code&gt; class we created at my day job.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#contributing-to-major-libraries" id="contributing-to-major-libraries"&gt;&lt;/a&gt;Contributing to Major Libraries&lt;/h2&gt;
&lt;p&gt;I’ve found myself able to move faster with FP languages as well, I’m able to read the source of major libraries in languages like Clojure and make contributions despite only having about a year of experience with it.&lt;/p&gt;
&lt;p&gt;After using JS for a decade at this point there are many libraries I can barely make heads or tails of. They’re not bad, it’s just more difficult for me to understand the intention of the code and find room for improvement. Much of what’s out there is very side-effect driven and organized in larger chunks of business logic. For instance at work our &lt;code&gt;Bid&lt;/code&gt; class has methods like &lt;code&gt;accept&lt;/code&gt; which updates db state of several models, sends several emails to clients and partners, and populates another dependent model representing proposal data.  It feels like a lot but I’m unsure what the purpose of the method actually is.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#modeling-and-universal-principles" id="modeling-and-universal-principles"&gt;&lt;/a&gt;Modeling and Universal Principles&lt;/h2&gt;
&lt;p&gt;Lastly, I like how you can model real-world domains in FP. It feels more intuitive to me and I think is easier to explain to other people outside of the tech industry. &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;https://pragprog.com/book/swdddf/domain-modeling-made-functional&lt;/a&gt; is a great book on that topic and raises a good point that OOP does miss the mark in a lot of places, especially when you inevitably need classes like BidManager or PageFactory that don’t really map to anything in the domain.&lt;/p&gt;
&lt;p&gt;My favorite part about learning FP is how universal those principles are, I can apply them to Elixir, Clojure, Python, Ruby, PHP, JS, and I’m sure even more languages out there. Transitioning between functional programming languages feels like it’s just a matter of learning the syntax.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#visualizing-functional-programming" id="visualizing-functional-programming"&gt;&lt;/a&gt;Visualizing Functional Programming&lt;/h2&gt;
&lt;p&gt;A metaphor I really like to use is the Lego Great-Ball-Contraptions:&lt;/p&gt;
&lt;iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/Kp62YVtejiY"
  frameborder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;You have many different machines (functions) that operate on balls (common data types). In OOP the equivalent would be wrapping each ball in a new container so another machine can work with it then either unwrapping it or wrapping another container over the ball’s container for the next machine.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#oop-is-not-evil-but-what-we-have-done-with-it-could-be" id="oop-is-not-evil-but-what-we-have-done-with-it-could-be"&gt;&lt;/a&gt;OOP is not evil but what we have done with it could be&lt;/h2&gt;
&lt;p&gt;For the record I don’t despise OOP or think FP itself is what lead to my improvement, it’s more that I gained a new way of thinking and solving problems. I think there are contexts where OOP is the right choice (especially game programming) but there’s a lot of places where we reach for OOP or imperative programming that could be better tackled with a FP or FP-inspired approach.&lt;/p&gt;
&lt;blockquote class="disclaimer"&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: Originally my response to a reddit question:&lt;br /&gt;
&lt;a href="https://www.reddit.com/r/elixir/comments/ac7m4t/is_it_true_that_by_learning_functional_language/"&gt;Is it true that learning functional programming makes you a better programmer?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="clojure"></category><category term="elixir"></category><category term="experience"></category></entry><entry><id>urn:uuid:a811549b-242e-46dc-8813-27c9d20e5a9d</id><title>Site Launch &#x1f389;</title><link href="https://eccentric-j.com/blog/1-site-launch.html" type="text/html" title="Site Launch &#x1f389;" rel="alternate"></link><published>2019-01-25T23:00:00Z</published><updated>2019-01-29T19:05:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/1-site-launch.html">&lt;h1&gt;&lt;a href="#why-even-make-a-blog-in-2019" id="why-even-make-a-blog-in-2019"&gt;&lt;/a&gt;Why even make a blog in 2019?&lt;/h1&gt;
&lt;p&gt;Likely lost in the void, I know, but I want to share some thoughts on functional programming and professional software engineering that mean a lot to me. Kind reddit commenters have &lt;a href="https://www.reddit.com/r/elixir/comments/ac7m4t/is_it_true_that_by_learning_functional_language/ed7qaqz/"&gt;unexpectedly&lt;/a&gt; &lt;a href="https://www.reddit.com/r/Clojure/comments/9ycubu/is_learning_clojure_a_good_idea_for_me/ea1b42n/"&gt;encouraged&lt;/a&gt; me to publish some of my meatier posts in functional programming subreddits. Now I have a place to publish them to.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#what-will-this-blog-cover" id="what-will-this-blog-cover"&gt;&lt;/a&gt;What will this blog cover?&lt;/h1&gt;
&lt;p&gt;This blog covers functional programming topics in languages like Clojure and ClojureScript. I may cover JavaScript, Elixir, Haskell, and Elm, but I intend to focus on Clojure and ClojureScript more since I enjoy working with them the most.&lt;/p&gt;
&lt;p&gt;I will also publish announcements of upcoming projects, tutorials\learning resources, open-ended ideas, and opinions on professional practices.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#what-platform-should-i-use" id="what-platform-should-i-use"&gt;&lt;/a&gt;What platform should I use?&lt;/h1&gt;
&lt;p&gt;This took a long time to decide. Wanting to tryout a &lt;a href="https://jamstack.org/"&gt;JAMstack&lt;/a&gt; a statically generated site felt the most enticing. Hugo and Jekyll seem really nice but I know I would be more motivated to keep working on it if it were in Clojure.  For building the static files I chose &lt;a href="https://perun.io/"&gt;https://perun.io/&lt;/a&gt; which is based on &lt;a href="https://github.com/boot-clj"&gt;Boot&lt;/a&gt; build tasks. I really like the concept of composing small tasks together to form larger bodies of functionality so it felt like a natural fit. Development moved fast and I am happy with the result so far. Now I have this powerful framework I can keep improving over time without investing too much time to bring ideas to life.&lt;/p&gt;
&lt;p&gt;For example the production build pipeline looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clj"&gt;(deftask build
  &amp;quot;Build the blog source and output to target/public&amp;quot;
  [e build-env BUILD-ENV kw    &amp;quot;Environment keyword like :dev or :production&amp;quot;]
  (let [prod? (= build-env :prod)]
   (pipeline
     (generate-site :prod? prod?)
     (seo-files prod?)
     (cljs :ids [&amp;quot;prod&amp;quot;])
     (sass :output-style :compressed :source-map false)
     (clean :exclude [#&amp;quot;.git&amp;quot;])
     (target :no-clean true)
     (notify))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The rest of the source is available at &lt;a class="brand fa-github" href="https://github.com/eccentric-j/idle-parens"&gt;eccentric-j/idle-parens&lt;/a&gt; if you are the slightest bit curious how it all came together.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#are-you-really-eccentric" id="are-you-really-eccentric"&gt;&lt;/a&gt;Are you really &lt;em&gt;eccentric&lt;/em&gt;?&lt;/h1&gt;
&lt;p&gt;No. Probably not. It felt like a nice word to embody my awkwardness along with my love of programming, cats, black\death metal, skulls, and occult imagery. While I’m more of a straight arrow than someone riding the line between the accepted norms and taboos of society I can dream can’t I? Who uses the internet to face the realities of who they actually are? That’s madness! &#x1f608;&lt;/p&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="blog"></category><category term="projects"></category></entry></feed>