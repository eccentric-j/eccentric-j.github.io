<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Eccentric J</title><subtitle>Eccentric J's blog on Functional Programming, Clojure, and Engineering</subtitle><generator uri="https://perun.io/" version="0.4.2-SNAPSHOT">Perun</generator><link href="https://eccentric-j.com/" type="text/html"></link><link href="https://eccentric-j.com/atom.xml" rel="self"></link><link href="https://eccentric-j.com/atom.xml" rel="first"></link><link href="https://eccentric-j.com/atom.xml" rel="last"></link><updated>2019-02-01T00:09:02Z</updated><id>https://eccentric-j.com/</id><entry><id>urn:uuid:db151ec4-50b8-42f9-b20e-2153cb5d93f2</id><title>My Functional Programming Experience</title><link href="https://eccentric-j.com/blog/3-functional-programming-experience.html" type="text/html" title="My Functional Programming Experience" rel="alternate"></link><published>2019-01-29T00:31:00Z</published><updated>2019-01-29T18:52:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/3-functional-programming-experience.html">&lt;h1&gt;&lt;a href="#discovering-functional-programming" id="discovering-functional-programming"&gt;&lt;/a&gt;Discovering Functional Programming&lt;/h1&gt;
&lt;p&gt;I first encountered the phrase &amp;ldquo;Functional Programming&amp;rdquo; when learning about Redux for JS. My first question was &amp;ldquo;Isn’t all programming functional?&amp;rdquo; then I began researching it and got genuinely curious and found the motivation to study it further. Now about 2 years into it I can confirm it has deeply impacted how I think, work, and the trajectory of my career.&lt;/p&gt;
&lt;p&gt;When I started learning I was really in the weeds with OOP and wanted to abstract, generalize, and use all those fancy OOP patterns everywhere it made sense. The problem is whenever you create a custom class in most languages, it’s incompatible with everything else. Even in JS if I extend an array class it’s often treated as a separate type. So you often have to write more classes to make two classes talk to each other.&lt;/p&gt;
&lt;p&gt;In addition to those layers of abstraction for OOP I think there’s no upper limit to the complexity you can achieve and the vocabulary to describe OOP systems. Getters, setters, public, private, accessors, attributes, methods, virtual properties, constructor overrides, generics, magic methods, over loading, dependency injections, super, child,  inheritance, the list goes on I’m sure.&lt;/p&gt;
&lt;p&gt;With functional programming I find it has a pretty fixed amount of concepts that make up the methodology:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immutability&lt;/li&gt;
&lt;li&gt;Pure Functions&lt;/li&gt;
&lt;li&gt;Referential Transparency&lt;/li&gt;
&lt;li&gt;Composition&lt;/li&gt;
&lt;li&gt;Higher Order Functions&lt;/li&gt;
&lt;li&gt;Core Data Types&lt;/li&gt;
&lt;li&gt;Functors&lt;/li&gt;
&lt;li&gt;Monads&lt;/li&gt;
&lt;li&gt;Point Free&lt;/li&gt;
&lt;li&gt;Predicates&lt;/li&gt;
&lt;li&gt;Map, Filter, Reduce functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That may not be every concept but it is more than enough to build a strong sense of competency with the methodology.&lt;/p&gt;
&lt;p&gt;What’s great about learning those is that they all build on each other where as a lot of those OOP concepts are kind of parallel to each other where you can learn one without knowing the other.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#types-of-functional-programming-languages" id="types-of-functional-programming-languages"&gt;&lt;/a&gt;Types of Functional Programming Languages&lt;/h2&gt;
&lt;p&gt;There’s two major camps that functional programming falls into:&lt;/p&gt;
&lt;h3&gt;&lt;a href="#dynamic-languages" id="dynamic-languages"&gt;&lt;/a&gt;Dynamic Languages&lt;/h3&gt;
&lt;p&gt;Languages like Elixir and Clojure fall into this camp. They leverage dynamic types and focus on creating pipelines of functions to transform data. These languages also tend to be more side-effect friendly with looser restrictions but agreed upon naming conventions to denote when side effects happen. Generally these languages have a more practical nature to them focusing on getting work done.&lt;/p&gt;
&lt;h3&gt;&lt;a href="#static-languages" id="static-languages"&gt;&lt;/a&gt;Static Languages&lt;/h3&gt;
&lt;p&gt;Languages like Elm, F#, OCaml or Haskell fall into this camp. They emphasize type theory and other mathematic principles to leverage monads, or data types that represent computation builders to do most of the work. For instance the Array type in JS is a monad, it can be mapped to an array of other values, packed, and unpacked in itself. These languages are more strict about side effects often requiring them to be wrapped in a IO monad or similar system to separate out side-effect work from pure functions. While they can be used for practical work they often have an academic background and require more specification in determining the correctness of a program. For instance your program might not compile until you specify which types a function receives and returns.&lt;/p&gt;
&lt;h4&gt;&lt;a href="#other-languages" id="other-languages"&gt;&lt;/a&gt;Other Languages&lt;/h4&gt;
&lt;p&gt;Languages like JS, Ruby, and Python have some functional capabilities but I don’t consider them functional programming languages for the sake of this discussion. You can of course apply functional programming concepts to or within these languages.&lt;/p&gt;
&lt;h4&gt;&lt;a href="#comparison" id="comparison"&gt;&lt;/a&gt;Comparison&lt;/h4&gt;
&lt;p&gt;In so far I don’t strongly feel one camp is better than another, I’ve just noticed that functional programming languages tend to lean to one side more than the other. While I’ve chosen to focus on Clojure and Elixir for now, I’m also interested in learning and hearing about Haskell and Elm.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#does-functional-programming-make-you-a-better-programmer" id="does-functional-programming-make-you-a-better-programmer"&gt;&lt;/a&gt;Does functional programming make you a better programmer?&lt;/h2&gt;
&lt;p&gt;As far as improving as a programmer and engineer: I think putting in the time and effort to learning it will impact you for the better. I’ve learned how to reduce complexity in the work I produce by composing larger systems from smaller functions that have very specific jobs, often aimed at expressing a domain-specific goal with pure functions as much as possible. This means fewer surprises for other programmers and stronger testability because testing pure functions like &lt;code&gt;add(1, 2)&lt;/code&gt; is much easier than testing classes, instances, and runtime app state like &lt;code&gt;this.router.handleRoute(window.location)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Instead of trying to make more complex data types like I did when strictly using OOP, I find myself mostly leaning on core types. Elixir is a great example; Elixir has hundreds of functions that can work on lists, maps, streams, and files. It has zero that work on that &lt;code&gt;Bid&lt;/code&gt; class we created at my day job.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#contributing-to-major-libraries" id="contributing-to-major-libraries"&gt;&lt;/a&gt;Contributing to Major Libraries&lt;/h2&gt;
&lt;p&gt;I’ve found myself able to move faster with FP languages as well, I’m able to read the source of major libraries in languages like Clojure and make contributions despite only having about a year of experience with it.&lt;/p&gt;
&lt;p&gt;After using JS for a decade at this point there are many libraries I can barely make heads or tails of. They’re not bad, it’s just more difficult for me to understand the intention of the code and find room for improvement. Much of what’s out there is very side-effect driven and organized in larger chunks of business logic. For instance at work our &lt;code&gt;Bid&lt;/code&gt; class has methods like &lt;code&gt;accept&lt;/code&gt; which updates db state of several models, sends several emails to clients and partners, and populates another dependent model representing proposal data.  It feels like a lot but I’m unsure what the purpose of the method actually is.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#modeling-and-universal-principles" id="modeling-and-universal-principles"&gt;&lt;/a&gt;Modeling and Universal Principles&lt;/h2&gt;
&lt;p&gt;Lastly, I like how you can model real-world domains in FP. It feels more intuitive to me and I think is easier to explain to other people outside of the tech industry. &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;https://pragprog.com/book/swdddf/domain-modeling-made-functional&lt;/a&gt; is a great book on that topic and raises a good point that OOP does miss the mark in a lot of places, especially when you inevitably need classes like BidManager or PageFactory that don’t really map to anything in the domain.&lt;/p&gt;
&lt;p&gt;My favorite part about learning FP is how universal those principles are, I can apply them to Elixir, Clojure, Python, Ruby, PHP, JS, and I’m sure even more languages out there. Transitioning between functional programming languages feels like it’s just a matter of learning the syntax.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#visualizing-functional-programming" id="visualizing-functional-programming"&gt;&lt;/a&gt;Visualizing Functional Programming&lt;/h2&gt;
&lt;p&gt;A metaphor I really like to use is the Lego Great-Ball-Contraptions:&lt;/p&gt;
&lt;iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/Kp62YVtejiY"
  frameborder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;You have many different machines (functions) that operate on balls (common data types). In OOP the equivalent would be wrapping each ball in a new container so another machine can work with it then either unwrapping it or wrapping another container over the ball’s container for the next machine.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#oop-is-not-evil-but-what-we-have-done-with-it-could-be" id="oop-is-not-evil-but-what-we-have-done-with-it-could-be"&gt;&lt;/a&gt;OOP is not evil but what we have done with it could be&lt;/h2&gt;
&lt;p&gt;For the record I don’t despise OOP or think FP itself is what lead to my improvement, it’s more that I gained a new way of thinking and solving problems. I think there are contexts where OOP is the right choice (especially game programming) but there’s a lot of places where we reach for OOP or imperative programming that could be better tackled with a FP or FP-inspired approach.&lt;/p&gt;
&lt;blockquote class="disclaimer"&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: Originally my response to a reddit question:&lt;br /&gt;
&lt;a href="https://www.reddit.com/r/elixir/comments/ac7m4t/is_it_true_that_by_learning_functional_language/"&gt;Is it true that learning functional programming makes you a better programmer?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="clojure"></category><category term="elixir"></category><category term="experience"></category></entry><entry><id>urn:uuid:a811549b-242e-46dc-8813-27c9d20e5a9d</id><title>Site Launch &#x1f389;</title><link href="https://eccentric-j.com/blog/1-site-launch.html" type="text/html" title="Site Launch &#x1f389;" rel="alternate"></link><published>2019-01-25T23:00:00Z</published><updated>2019-01-29T19:05:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/1-site-launch.html">&lt;h1&gt;&lt;a href="#why-even-make-a-blog-in-2019" id="why-even-make-a-blog-in-2019"&gt;&lt;/a&gt;Why even make a blog in 2019?&lt;/h1&gt;
&lt;p&gt;Likely lost in the void, I know, but I want to share some thoughts on functional programming and professional software engineering that mean a lot to me. Kind reddit commenters have &lt;a href="https://www.reddit.com/r/elixir/comments/ac7m4t/is_it_true_that_by_learning_functional_language/ed7qaqz/"&gt;unexpectedly&lt;/a&gt; &lt;a href="https://www.reddit.com/r/Clojure/comments/9ycubu/is_learning_clojure_a_good_idea_for_me/ea1b42n/"&gt;encouraged&lt;/a&gt; me to publish some of my meatier posts in functional programming subreddits. Now I have a place to publish them to.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#what-will-this-blog-cover" id="what-will-this-blog-cover"&gt;&lt;/a&gt;What will this blog cover?&lt;/h1&gt;
&lt;p&gt;This blog covers functional programming topics in languages like Clojure and ClojureScript. I may cover JavaScript, Elixir, Haskell, and Elm, but I intend to focus on Clojure and ClojureScript more since I enjoy working with them the most.&lt;/p&gt;
&lt;p&gt;I will also publish announcements of upcoming projects, tutorials\learning resources, open-ended ideas, and opinions on professional practices.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#what-platform-should-i-use" id="what-platform-should-i-use"&gt;&lt;/a&gt;What platform should I use?&lt;/h1&gt;
&lt;p&gt;This took a long time to decide. Wanting to tryout a &lt;a href="https://jamstack.org/"&gt;JAMstack&lt;/a&gt; a statically generated site felt the most enticing. Hugo and Jekyll seem really nice but I know I would be more motivated to keep working on it if it were in Clojure.  For building the static files I chose &lt;a href="https://perun.io/"&gt;https://perun.io/&lt;/a&gt; which is based on &lt;a href="https://github.com/boot-clj"&gt;Boot&lt;/a&gt; build tasks. I really like the concept of composing small tasks together to form larger bodies of functionality so it felt like a natural fit. Development moved fast and I am happy with the result so far. Now I have this powerful framework I can keep improving over time without investing too much time to bring ideas to life.&lt;/p&gt;
&lt;p&gt;For example the production build pipeline looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clj"&gt;(deftask build
  &amp;quot;Build the blog source and output to target/public&amp;quot;
  [e build-env BUILD-ENV kw    &amp;quot;Environment keyword like :dev or :production&amp;quot;]
  (let [prod? (= build-env :prod)]
   (pipeline
     (generate-site :prod? prod?)
     (seo-files prod?)
     (cljs :ids [&amp;quot;prod&amp;quot;])
     (sass :output-style :compressed :source-map false)
     (clean :exclude [#&amp;quot;.git&amp;quot;])
     (target :no-clean true)
     (notify))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The rest of the source is available at &lt;a class="brand fa-github" href="https://github.com/eccentric-j/idle-parens"&gt;eccentric-j/idle-parens&lt;/a&gt; if you are the slightest bit curious how it all came together.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#are-you-really-eccentric" id="are-you-really-eccentric"&gt;&lt;/a&gt;Are you really &lt;em&gt;eccentric&lt;/em&gt;?&lt;/h1&gt;
&lt;p&gt;No. Probably not. It felt like a nice word to embody my awkwardness along with my love of programming, cats, black\death metal, skulls, and occult imagery. While I’m more of a straight arrow than someone riding the line between the accepted norms and taboos of society I can dream can’t I? Who uses the internet to face the realities of who they actually are? That’s madness! &#x1f608;&lt;/p&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="blog"></category><category term="projects"></category></entry></feed>