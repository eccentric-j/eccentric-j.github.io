<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Eccentric J</title><subtitle>Eccentric J's blog on Functional Programming, Clojure, and Engineering</subtitle><generator uri="https://perun.io/" version="0.4.2-SNAPSHOT">Perun</generator><link href="https://eccentric-j.com/" type="text/html"></link><link href="https://eccentric-j.com/atom.xml" rel="self"></link><link href="https://eccentric-j.com/atom.xml" rel="first"></link><link href="https://eccentric-j.com/atom.xml" rel="last"></link><updated>2020-09-29T23:46:27Z</updated><id>https://eccentric-j.com/</id><entry><id>urn:uuid:865C58D3-F5B4-4681-8762-87BB86F86E91</id><title>Our biggest obstacles are in our own minds</title><link href="https://eccentric-j.com/blog/biggest-obstacles.html" type="text/html" title="Our biggest obstacles are in our own minds" rel="alternate"></link><published>2020-06-29T02:29:00Z</published><updated>2020-06-29T02:29:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/biggest-obstacles.html">&lt;p&gt;You might be thinking, ‚ÄúNo it‚Äôs not! It‚Äôs completing my not-yet-open-sourced AutomaticCrudAbstractionLayer UI to communicate with my upcoming patent for my FormAbstractionOnTopOfAFormLayer wrapper to dispatch EventNodes to my reducer service to deterministically update my store state. Then I‚Äôm going to produce a framework with it to build a platform and sell it a software-as-a-service product!‚Äù Perhaps in a way, that is an obstacle, but then let‚Äôs ask, ‚ÄúWhat gets in the way of me accomplishing that?‚Äù Some more more practical reasons may come up, but eventually we may realize a lot of those stem from what‚Äôs in the minds. Distractions, fears, wants, needs, anger, and especially more complex problems like indecisiveness and anxiety constantly get in the way of a person achieving their goals. One may not even notice how much such obstacles can get in their way on a nearly constant basis.&lt;/p&gt;
&lt;p&gt;The biggest issue I‚Äôve seen engineers new and old wrestle with is ego. Ego can really mess one up by causing themself and each other a lot of pain. An uncontested, poorly researched theory of mine is that building software makes us feel like geniuses and without care, we start to believe it.&lt;/p&gt;
&lt;p&gt;When we get to that point we believe every line of code, thought, or criticism must be genius as well. I‚Äôm guilty of moments like that myself. Sometimes when discussing software dev with other programmers of other languages part of my brain foolishly screams, &amp;ldquo;TELL THEM ABOUT CLOJURE CLOJURE IS AWESOME CLOJURE IS GREAT KEEEP THINGS SSSIIIMMMPLLEEE USE CllooJjjuurEEE&amp;rdquo; over and over and over again. That is my ego. The truth is I prefer Clojure because it feels productive, and enjoyable to me. But others have tried it and moved on, some will never try it for various reasons, and others may find it simply doesn‚Äôt meet their needs or spark joy in them like it does for me.&lt;/p&gt;
&lt;p&gt;They‚Äôre not wrong, they‚Äôre not unenlightened. I think it‚Äôs to the benefit of everyone to learn languages that work differently than what we‚Äôre used to, but that‚Äôs not something I should force on others. I am not better than them because I‚Äôve found a language I prefer over the conventional options, I‚Äôm not better because I did try to learn something different than what I‚Äôm used to. Time is expensive, I can‚Äôt be upset or look down on others because they want to spend it differently.&lt;/p&gt;
&lt;p&gt;Ego is not good for us because it stops us from growing. It wants to tell us we‚Äôre right no matter how much research may indicate otherwise. It tells us one stack and one way is the best way which is difficult to prove given that there are nearly infinite ways to accomplish anything in software engineering. It‚Äôs the CTO that refuses to listen to an intern because they‚Äôre an intern. Ego strikes when a team lead tells a coworker not to say the lead is blocking them in a standup because it makes them look bad. It can be dangerously subtle if the ego subconsciously ignores advice that is not presented by an older, white-male authority figure. Ego needs to be the smartest person in the room. It‚Äôs when a contact tells us they‚Äôre excited about a new tool, framework, or language and ego drives one to immediately start Googling for why it sucks. It‚Äôs especially present when a developer carelessly ignore obligations and pursue perfection.&lt;/p&gt;
&lt;p&gt;One way to help maintain balance with ego is through meditation. Meditation will not make those issues go away, but through practice we learn to observe those feelings in the mind in a openly, analytical but more detached way, like reading the docs on a new programming language you‚Äôve been meaning to learn.&lt;/p&gt;
&lt;p&gt;Checking ego does not mean avoiding skepticism or criticism. Those are necessary discussions to help everyone grow and to keep each other and work in balance. But there is a difference between insightful, healthy criticism benefits everyone the ego-driven criticism pulls everyone around it down to justify an unearned position of superiority. Meditation does not destroy ego on its own, but it does help one take a step back from their thoughts and reactions to start questioning where they come from, observing them from afar instead of riding them like a roller-coaster of destruction.&lt;/p&gt;
&lt;p&gt;A challenging aspect towards this is understanding that while meditating one day, a practitioner does not become enlightened, and their ego is gone. Instead, quietly observing thoughts becomes a skill, the kind that degrades quickly if practice is not kept up. If you‚Äôre serious about giving it a shot, make it a routine. Make it a key part of your day and give it your full attention. &lt;a href="https://youtu.be/oytL881p-nQ"&gt;It is not easy, but it is simple&lt;/a&gt;. üòè&lt;/p&gt;
&lt;p&gt;Follow along next week as I discuss how practicing meditation can help us as software engineers keep egos in check and increase awareness of the mental obstacles that hinder personal progress. While I‚Äôm not anticpating transforming into a spiritual blog, I‚Äôve acquired some practical experience to share to help people who are interested to get started.&lt;/p&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="experience"></category><category term="reflection"></category><category term="clojure"></category></entry><entry><id>urn:uuid:70384D51-ECA5-422E-B682-A7D2F4D93835</id><title>My gentle introduction to hard-core open-source contribution</title><link href="https://eccentric-j.com/blog/contributing-to-open-source.html" type="text/html" title="My gentle introduction to hard-core open-source contribution" rel="alternate"></link><published>2019-06-24T02:16:42Z</published><updated>2019-06-27T19:55:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/contributing-to-open-source.html">&lt;p&gt;Back when I started learning Clojure, I never believed I would be able to contribute to a substantial library. After only a year and a half, I was able to refactor some of &lt;a href="https://nrepl.org/"&gt;nREPL&lt;/a&gt;‚Äôs command-line logic! Not only was the process enjoyable, but I also learned a lot from experienced maintainers. This article reflects on my first contribution to a significant Clojure library. I hope others feel encouraged to contribute to major open-source projects as well.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#the-problem" id="the-problem"&gt;&lt;/a&gt;The Problem&lt;/h2&gt;
&lt;p&gt;I wanted to reuse nREPL‚Äôs command-line logic to provide a more engaging &lt;abbr title="Read-Eval-Print-Loop" class="initialism"&gt;REPL&lt;/abbr&gt; experience for new users.  Unfortunately, the command-line logic I required was &lt;a href="https://github.com/nrepl/nrepl/blob/054be705c057d352c4eddfceb68fc0c0c17e25aa/src/clojure/nrepl/cmdline.clj#L242"&gt;one lengthy function&lt;/a&gt; with many side-effects.  While I wouldn‚Äôt call it bad code, I would have to copy and change many parts of it.  If nREPL‚Äôs cmdline interface changes between versions, it may break my library.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#why-was-clojure-more-approachable" id="why-was-clojure-more-approachable"&gt;&lt;/a&gt;Why was Clojure more approachable?&lt;/h2&gt;
&lt;p&gt;While I have more experience in other languages, I never found myself able to contribute much.  What is it about Clojure that made it feel more natural for me to jump in and start contributing?&lt;/p&gt;
&lt;h3&gt;&lt;a href="#1-clojure-makes-the-intent-of-functions-clear" id="1-clojure-makes-the-intent-of-functions-clear"&gt;&lt;/a&gt;1. Clojure makes the intent of functions clear&lt;/h3&gt;
&lt;p&gt;Clojure encourages developers to write pure and simple functions that can be composed to solve complex problems.  This pattern breaks down harder problems into smaller, more manageable pieces.  Pure functions only use their arguments to calculate and return output.  They do not affect the outside world and have a clear intent.  In contrast, functions that have many side-effects tend to blur intent.  A Clojure function with unclear intent is an excellent place to start a refactor.  For instance, the original &lt;a href="https://github.com/nrepl/nrepl/blob/054be705c057d352c4eddfceb68fc0c0c17e25aa/src/clojure/nrepl/cmdline.clj#L242"&gt;nREPL cmdline code&lt;/a&gt; has a lot going on.  It dispatches sub-commands, starts servers, connects to servers, and starts the REPL interface.  This meaty function became my starting point.  Refactoring that function improves the library and also solves my reusability problem as well.&lt;/p&gt;
&lt;h3&gt;&lt;a href="#2-functional-programming-principles-keep-peoples-efforts-in-sync" id="2-functional-programming-principles-keep-peoples-efforts-in-sync"&gt;&lt;/a&gt;2. Functional Programming Principles Keep People&amp;rsquo;s Efforts in Sync&lt;/h3&gt;
&lt;p&gt;One of my favorite aspects of functional programming is how principled it is. Principles like immutability, first-class functions, purity, and composability help keep programs simple. While developers can use them in most languages, it relies on team discipline to stick to them. Instead, functional programming languages, like Clojure, bake functional principles into their core. When Clojure code defies those principles, it sticks out like a sore thumb.&lt;/p&gt;
&lt;p&gt;Functional principles have full buy-in from the community in languages like Clojure as well.  The mindshare provides an intuition for how to design programs.  Small, pure functions form pipelines to build up more meaningful data over time.  Side-effects nestle at the edges of programs, such as the beginning or end of pipelines.  Having that common intuition made learning how nREPL works quite simple.  That ease of learning felt quite unlike my experience with Node, where you find gigantic functions with many side effects.  A single function may use mutable state, nested callbacks, and complex decision trees.  Both Node source code and &lt;a href="https://github.com/auth0/node-jsonwebtoken/blob/master/verify.js#L18"&gt;community NPM modules&lt;/a&gt; have chunky, confusing functions.  Where would you even begin to refactor that?  It often feels like there are no principles but a wild-west of do-whatever-makes-sense or seems-to-work-at-the-time.  When a program is made up of many small functions with clear intent, it is much easier to refactor.  Programs with lengthier functions that cause many side-effects often require massive rewrites.&lt;/p&gt;
&lt;p&gt;The principled design also made it easy to make a public case for my refactor.  I was able to express how such a meaty function was not reusable, testable, and inhibited my side project.  Without shared principles, proving the value in a refactor can be more difficult.  I only had to show how that code works against the principles followed in the rest of the project.  Without the principles, I would be stuck arguing that my style is somehow better than the actual working code &#x1f635;&lt;/p&gt;
&lt;h3&gt;&lt;a href="#3-isolated-blocks" id="3-isolated-blocks"&gt;&lt;/a&gt;3. Isolated Blocks&lt;/h3&gt;
&lt;p&gt;Since Clojure code leverages pure functions, my code still works provided my functions take similar input and return the expected output.  The automated tests also further proved that I did not break any existing behavior as well.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#getting-started" id="getting-started"&gt;&lt;/a&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;Before starting this project, I felt a bit of doubt and uncertainty.  How do I know if I‚Äôm solving a real problem or if I am only nit-picking aesthetics?  I took to the Clojurians Slack and asked if there was merit in my issues.  I wanted to be sure I‚Äôm taking up maintainers time for something valuable.&lt;br /&gt;
The Clojurian sages in Slack gave me some great advice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an issue first, so maintainers verify the problem and your proposed solution.&lt;/li&gt;
&lt;li&gt;Focus the issue on the problem the code creates instead of attacking how the code looks.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="#the-process" id="the-process"&gt;&lt;/a&gt;The Process&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Created an &lt;a href="https://github.com/nrepl/nrepl/issues/108"&gt;issue on GitHub&lt;/a&gt; to identify the problem and propose a solution&lt;/li&gt;
&lt;li&gt;After discussion, started drafting the implementation&lt;/li&gt;
&lt;li&gt;Created a &lt;a href="https://github.com/nrepl/nrepl/pull/116"&gt;GitHub pull-request&lt;/a&gt; with my refactor draft&lt;/li&gt;
&lt;li&gt;Discussed the pull-request with project maintainers&lt;/li&gt;
&lt;li&gt;Refined the implementation based on the pull-request feedback&lt;/li&gt;
&lt;li&gt;Wrote tests for the new functions I created&lt;/li&gt;
&lt;li&gt;Added a feature suggested by Bozhidar: &lt;br /&gt; A &lt;code&gt;repl-fn&lt;/code&gt; option to swap out the interactive REPL function&lt;/li&gt;
&lt;li&gt;Added tests to confirm the &lt;code&gt;repl-fn&lt;/code&gt; option behavior&lt;/li&gt;
&lt;li&gt;Pull request was approved, then merged into the master branch&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="#what-did-i-learn" id="what-did-i-learn"&gt;&lt;/a&gt;What did I learn?&lt;/h2&gt;
&lt;dl class="dl--title-size_3 dl--title-mb_1 ml-3"&gt;
  &lt;dt&gt;Be diplomatic&lt;/dt&gt;
  &lt;dd&gt;&lt;p&gt;Raise issues around a problem instead of criticizing others' code.&lt;/p&gt;&lt;/dd&gt;
  &lt;dt&gt;Pick battles that are worth the time&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;
      Pick battles that are worth the time.  Everyone is busy, pick meaningful battles about architecture and design.  Not details like if side effect functions should end with a &lt;code&gt;!&lt;/code&gt; or not.  Try to keep your contributions aligned with the maintainer's goals.
    &lt;/p&gt;
  &lt;/dd&gt;
  &lt;dt&gt;You can learn a lot by reading the source code&lt;/dt&gt;
  &lt;dd&gt;&lt;p&gt;From reading nREPL's source, I learned how to develop more robust and sophisticated &lt;abbr title="Command Line Interface" class="initialism"&gt;CLI&lt;/abbr&gt;s in Clojure.&lt;/p&gt;&lt;/dd&gt;
  &lt;dt&gt;Squash commits before merging&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;
      Using git rebase to squash commits before merging keeps git history meaningful.  Now the whole refactor I did lives in one commit!  If I introduced a bug, a smart tool like &lt;code&gt;git bisect&lt;/code&gt; could pinpoint my commit, making it safer to revert.
    &lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;&lt;a href="#what-could-i-have-done-better" id="what-could-i-have-done-better"&gt;&lt;/a&gt;What could I have done better?&lt;/h2&gt;
&lt;p&gt;Reflecting on the experience, a few areas for improvement come to mind:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Maintainers&amp;rsquo; time is valuable. I had asked a few questions that I could have answered with a little more research. I should try to research answers on my own first before publicly asking questions.&lt;/li&gt;
&lt;li&gt;Don‚Äôt expect step-by-step guidance. Sometimes I should draft a solution instead of waiting for step-by-step instructions or pre-approval.&lt;/li&gt;
&lt;li&gt;Be more mindful when explaining my design decisions. In some cases, I over-explained my rationale when it was already known and may have come off defensive. Too much defensiveness wears people down.&lt;/li&gt;
&lt;li&gt;Pace myself so that I‚Äôm not overworking one day then recovering the week after. On the days I limited my work on the nREPL to about 20 minutes, I had no problem picking it up the next day.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="#final-thoughts" id="final-thoughts"&gt;&lt;/a&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;Overall working with the nREPL maintainers was a great experience!  I enjoyed the project and learning from code reviews.  I hope my contributions are valuable, and my refactor helps others create beautiful REPL experiences.  Given how welcoming and informative the Clojure community is, I look forward to contributing to more projects.&lt;/p&gt;
&lt;p&gt;I want to give a major shout out to &lt;a href="https://metaredux.com/"&gt;Bozhidar Batsov&lt;/a&gt; (aka bbatsov).  He was responsive, open, and informative in guiding my inexperienced hands throughout the refactor. His stewardship is an excellent example of how to lead an open-source project.&lt;/p&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="experience"></category><category term="clojure"></category></entry><entry><id>urn:uuid:406fbf95-11d3-476b-8435-0c3c07fbff66</id><title>Announcing my Leiningen ClojureScript Terminal-User-Interface Application Template &#x1f389;</title><link href="https://eccentric-j.com/blog/5-announcing-cljs-tui-template.html" type="text/html" title="Announcing my Leiningen ClojureScript Terminal-User-Interface Application Template &#x1f389;" rel="alternate"></link><published>2019-02-24T23:30:00Z</published><updated>2019-02-26T07:24:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/5-announcing-cljs-tui-template.html">&lt;h2&gt;&lt;a href="#the-beginning" id="the-beginning"&gt;&lt;/a&gt;The Beginning&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve always wanted to make rich, expressive terminal-user-interface applications such as htop, vim, or tmux but felt deterred by the absurd amount of state that needs to be maintained even for the simplest of visual effects.&lt;/p&gt;
&lt;p&gt;Earlier this year someone posted a link to &lt;a href="https://github.com/denisidoro/floki"&gt;https://github.com/denisidoro/floki&lt;/a&gt; and it totally blew my mind! It&amp;rsquo;s a JSON browser written in ClojureScript using Reframe, Reagent, React, and Blessed with graphical windows and keyboard navigation. I had no idea &lt;a href="https://github.com/chjj/blessed"&gt;blessed&lt;/a&gt; even existed! I knew I had to make a template out of Denis&amp;rsquo; stack so others like myself can quickly make our own awesome terminal user interface applications.&lt;/p&gt;
&lt;p&gt;The project can be found at:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eccentric-j/cljs-tui-template"&gt;https://github.com/eccentric-j/cljs-tui-template&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#why-clojurescript" id="why-clojurescript"&gt;&lt;/a&gt;Why ClojureScript?&lt;/h2&gt;
&lt;p&gt;This is the first question most people will likely ask upon discovering this project. At this time however, I no longer believe in &amp;ldquo;best-tool-for-the-job&amp;rdquo;. It&amp;rsquo;s such a personal, relative, and temporary measure so I would rather not incite a language war trying to suggest how ClojureScript could be objectively better than any other language. Instead it&amp;rsquo;s currently the language I enjoy the most. Its ethos gels with mine and I enjoy the development process it overs and I hope this project inspires curiosity to give it a shot. That said I will share my reasons for enjoying it so much.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#functional-programming" id="functional-programming"&gt;&lt;/a&gt;Functional Programming&lt;/h2&gt;
&lt;p&gt;Functional programming provides strong principles that guide all implementation decisions. In most cases I&amp;rsquo;ve found it helps me make more reusable, simpler, and concise units of code I can compose together to make more complex systems. Because of the simpler pieces I find it&amp;rsquo;s much easier to test, write, document, maintain, and debug.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#clojure-syntax" id="clojure-syntax"&gt;&lt;/a&gt;Clojure Syntax&lt;/h2&gt;
&lt;p&gt;Clojure&amp;rsquo;s syntax is very different than traditional c-family languages since it&amp;rsquo;s in the LISP family. It was very jarring to me when I first encountered it, but I love it now. I will one day write an entire article about Clojure syntax but what in short it&amp;rsquo;s very consistent. There&amp;rsquo;s very few pieces to it and no operator precedence to memorize, forms have a strong visual structure to them I find easy to scan and can be edited quickly as structured data with simple keystrokes in well-suited editors.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#strong-dynamic-typing" id="strong-dynamic-typing"&gt;&lt;/a&gt;Strong, Dynamic Typing&lt;/h2&gt;
&lt;p&gt;I understand the value strong, static typing brings, but I personally prefer focusing my attention on getting an app to work versus writing specifications to prove that my program could work. ClojureScript makes JS a bit closer to a strongly typed, dynamic language which I feel offers a lot of flexibility but also more certainty than the loose, dynamic typing found in vanilla JS.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#live-editing" id="live-editing"&gt;&lt;/a&gt;Live editing&lt;/h2&gt;
&lt;p&gt;Develop faster using the ClojureScript REPL to send code straight from your editor to the app while preserving the runtime app state. It would be great to see a stronger REPL experience make its way into JS.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#low-boiling-point" id="low-boiling-point"&gt;&lt;/a&gt;Low boiling point&lt;/h2&gt;
&lt;p&gt;Since learning Clojure I spend far less time reading docs, and more time glancing at source code to solve my problems to get cooking faster. That&amp;rsquo;s not to say good documentation isn&amp;rsquo;t valuable, in Clojure I don&amp;rsquo;t often require much of it to make progress compared to my experience in other languages.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#faster-startup-with-clojurescript" id="faster-startup-with-clojurescript"&gt;&lt;/a&gt;Faster Startup with ClojureScript&lt;/h2&gt;
&lt;p&gt;Compared to Clojure, ClojureScript startup time is significantly faster running on node. This is important because CLIs or TUIs should fire up quickly.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#getting-started" id="getting-started"&gt;&lt;/a&gt;Getting Started&lt;/h1&gt;
&lt;p&gt;Poking around Floki&amp;rsquo;s source demonstrated how the required libs should fit together and how to develop the template with lein-figwheel and lein-cljsbuild. After some trial and error plus many questions in the Clojurians Slack I forged a simple, working prototype.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#lein-figwheel" id="lein-figwheel"&gt;&lt;/a&gt;Lein Figwheel&lt;/h1&gt;
&lt;p&gt;Just as soon as I moved towards the peak of this mountain I discovered an even larger peak: The creator of lein-figwheel created a successor project, figwheel-main, for building the JS. In addition to better documentation, it provides a more robust configuration strategy, better build performance, a rigid spec to test your configurations, and a project no longer needed the lein-cljsbuild companion plugin. Since I am both naive and foolish, I ambitiously embarked on supporting a figwheel-main option.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#figwheel-main" id="figwheel-main"&gt;&lt;/a&gt;Figwheel Main&lt;/h1&gt;
&lt;p&gt;Supporting figwheel-main turned into a more arduous task than expected. I&amp;rsquo;m having trouble pinpointing exactly why. It could be that for lein-figwheel I had a working example from floki to go by, or it could largely be the way the docs are organized. While figwheel-main has a lot more documentation than lein-figwheel it conflates practical guides with reference documentation. One of the initial struggles was having to figure out that your &lt;code&gt;figwheel-main.edn&lt;/code&gt; file only configures figwheel tooling behavior while your &lt;code&gt;&amp;lt;build-id&amp;gt;.cljs.edn&lt;/code&gt; files are essentially compile options for a specific build. You can override figwheel-main config from a cljs config by adding a meta hash-map to your cljs config map.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clojure"&gt;^{:watch-dirs [&amp;quot;src&amp;quot; &amp;quot;env/dev&amp;quot;]}
{:main my-test-project.app
 :asset-path           &amp;quot;target/js/compiled/dev&amp;quot;
 :output-to            &amp;quot;target/js/compiled/my-test-project.js&amp;quot;
 :output-dir           &amp;quot;target/js/compiled/dev&amp;quot;
 :target               :nodejs
 :optimizations        :none
 :source-map           true
 :source-map-timestamp true}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For instance the &lt;code&gt;:watch-dirs&lt;/code&gt; map overrides &lt;code&gt;figwheel-main.edn&lt;/code&gt; options. It makes some sense now but I think a &lt;code&gt;:figwheel&lt;/code&gt; key in the cljs.edn files would have been my preference.&lt;/p&gt;
&lt;p&gt;Another area where I think figwheel-docs lack is in node development, especially working with npm deps. The floki project uses the :npm-deps and :install-deps config options with lein-figwheel to manage the npm modules automatically. The advantage of this approach is that it automatically handles updating the package.json, installing deps, and allows ns imports, shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clojure"&gt;(ns my-test-project
  (:require [&amp;quot;react&amp;quot; :as react]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this syntax is preferred, I decided it would probably be better to make the template use package.json for deps so devs can make the most out of what npm offers. However, it turns out you cannot use the ns syntax from manual package.json deps. It only works using the ClojureScript :npm-deps and :install-deps build options. After some slack questions and testing against figwheel&amp;rsquo;s detailed config spec I found that js interop is the recommended way to use npm modules anyway.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clojure"&gt;(def react (js/require &amp;quot;react&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not quite as nice as the ns syntax but became essential for getting the test runner to work. I just couldn&amp;rsquo;t get tests to run with ns import syntax even with the :npm-deps and :install-deps build options. I created an &lt;a href="https://github.com/bhauman/figwheel-main/issues/148"&gt;issue in figwheel-main&lt;/a&gt; to learn more and discuss solutions.&lt;/p&gt;
&lt;p&gt;After stumbling my way to a working config with figwheel-main I once again had a running UI. While researching figwheel-main posts I noticed someone usually full-heartedly recommends shadow-cljs. Seeing so many comments like that convinced me it would be worth supporting as well. While it is yet another build tool to learn, this project has been a great excuse to give each cljs build tool a shot. So with a deep sigh I set off to reach the next mountain peak of this project.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#shadow-cljs" id="shadow-cljs"&gt;&lt;/a&gt;Shadow-CLJS&lt;/h2&gt;
&lt;p&gt;Shadow turned out to be amazing. Where as lein-figwheel was a small foothill and figwheel-main like free-climbing a mountain, shadow-cljs felt like walking along a boardwalk at a partially populated pier with a legal open-beverage policy. It&amp;rsquo;s very well documented and everything really did just work after a minimal amount of reading the docs and a few configuration attempts. It&amp;rsquo;s a very impressive tool and its attention is very well deserved. If you&amp;rsquo;re starting a green ClojureScript project I can&amp;rsquo;t recommend shadow-cljs enough. It even has very solid, official support for nodejs right out of the gate.&lt;/p&gt;
&lt;p&gt;The only noticeable caveat is that shadow doesn&amp;rsquo;t really support separate dev and production source paths like Clojure, lein-figwheel, and figwheel-main do. This template shows a debug box during development and captures log statements on the bottom half of the screen. However, devs wont likely want it there on production builds and I don&amp;rsquo;t want them to have to modify code to disable it between builds. I was able to work around this limitation by customizing the entry points between dev and production and the docs suggest the unused version will be factored out, but somehow I don&amp;rsquo;t feel as certain or good about it. I am very glad though that I was able to work around that and still deliver my intended developer experience.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#choosing-a-default-build-tool" id="choosing-a-default-build-tool"&gt;&lt;/a&gt;Choosing a default build tool&lt;/h2&gt;
&lt;p&gt;After adding support for shadow I had a decision to make: What should the default build tool be? At first I was leaning towards lein-figwheel as that&amp;rsquo;s what floki uses and is likely the most familiar to Clojure devs focusing on a project.clj config. Then I moved to figwheel-main due to its improved documentation and performance. Once I got shadow working however, it was clearly the best choice.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#why-is-shadow-cljs-the-default-build-tool" id="why-is-shadow-cljs-the-default-build-tool"&gt;&lt;/a&gt;Why is Shadow CLJS the default build tool?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Great documentation. Shadow-cljs&amp;rsquo; docs are organized into practical approaches for different kind of builds which meant I could mostly just use what was in the nodejs docs and move on. It didn&amp;rsquo;t feel like solving a puzzle like my experience with figwheel-main&amp;rsquo;s docs did.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Easier to configure. Everything goes into a single &lt;code&gt;shadow-cljs.edn&lt;/code&gt; file in your root project folder. Overriding the configuration for specific builds felt a bit more intuitive than the meta-data approach figwheel-main takes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No project.clj. Shadow is its own standalone npm module and doesn&amp;rsquo;t even require leiningen or a project.clj file. You instead place your Clojure dependencies in the &lt;code&gt;shadow-cljs.edn&lt;/code&gt; file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Automatic nREPL server. Both lein-figwheel and figwheel-main support running a nREPL server for ClojureScript but it&amp;rsquo;s not very intuitive. The process entails starting a regular Clojure nREPL server with &lt;code&gt;lein repl&lt;/code&gt; and starting a build server then the ClojureScript REPL interface from within the Clojure REPL. Shadow automatically starts a nREPL server when you start building for development which makes everything feel a lot more slick in my opinion. When connecting to the REPL you still have to start the shadow cljs REPL on top of the Clojure REPL but you also don&amp;rsquo;t need any nREPL middleware unlike figwheel-main and lein-figwheel which require the use of piggieback and sidecar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Active support community. The shadow-cljs slack channel is booming with activity and it&amp;rsquo;s creator &lt;a href="https://github.com/thheller"&gt;Thomas Heller&lt;/a&gt; is very helpful and responsive. Unfortunately given the complexity of ClojureScript tooling I suspect issues for users of this template will come up. When that happens I want them to be able to get the help they need quickly to unblock them and shadow-cljs is in a healthier place to do that.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Great nodejs testing support. Unlike lein-figwheel and figwheel-main shadow-cljs has a very solid testing setup for nodejs scripts and I found it to be very well documented. It took me a few hours to get lein-figwheel and figwheel-main tests to work but it only took a few minutes to get the shadow-cljs tests to run.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fewer layers. While mentioned briefly in previous points there are just fewer layers of tooling required to get shadow-cljs working and productive. In general I feel like the less layers of tools and abstraction the smoother and more maintainable the system. I&amp;rsquo;m sure there are exceptions but I think users will appreciate not having to configure lein and ClojureScript middleware on top of their package.json and build-tool specific tooling to get started.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="#dynamic-keyboard-listeners" id="dynamic-keyboard-listeners"&gt;&lt;/a&gt;Dynamic Keyboard Listeners&lt;/h2&gt;
&lt;p&gt;One of the more interesting problems I ran into was figuring out how to support dynamic key listeners. In floki there&amp;rsquo;s only one set of global keyboard events but what would you do if you had different &amp;ldquo;pages&amp;rdquo; that responded to different keys?&lt;/p&gt;
&lt;p&gt;Using blessed you can set bindings like the following where screen is a blessed Screen instance:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clojure"&gt;(.key screen #js [&amp;quot;q&amp;quot; &amp;quot;ESC&amp;quot;] #(rf/dispatch [:app/quit]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After reading through a bit more of Reagent&amp;rsquo;s docs I found my solution based on using &lt;code&gt;with-let&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clojure"&gt;(defn my-view
  [_]
  (with-keys @screen {[&amp;quot;escape&amp;quot; &amp;quot;q&amp;quot;] #(rf/dispatch [:app/quit])}
    [:box &amp;quot;Quit me. I dare you.&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This way the handlers are only created when the view is rendered but are destroyed when the view is removed. This means users can make pretty complex UI without having to juggle extra state to determine which set of key listeners to pay attention to. In the example I&amp;rsquo;m dispatching a reframe event but you can use local reagent atoms as well if you only want to affect local component state. That&amp;rsquo;s how the generated vertical menu view works.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#documentation" id="documentation"&gt;&lt;/a&gt;Documentation&lt;/h2&gt;
&lt;p&gt;Once all the builds were configured it is vital to provide good documentation. I want to ensure people familiar and new to Clojure can dive right in and get something up and running. To begin I first created a mind-map outline and went through several iterations of grouping related items together, removing extraneous topics, and rearranging groups until it felt right.&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;a href="/img/blog/5-cljs-tui-doc-outline.png" target="_cljs_tui_outline"&gt;
    &lt;img alt="Documentation Mind Map"
         src="/img/blog/5-cljs-tui-doc-outline.png"
         width="25%" /&gt;
  &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;When the mind map felt right I then broke each section or large section of text into separate tasks in my project board. From previous projects, I get diminishing returns trying to crank out a lot of docs at once. By writing it in short bursts over time I was able to refine it to my liking before asking others in the Clojure Slack to review it incase I missed anything. There were many times I would come back to a docs section I wrote the day before and find it very rough, verbose, and meandering so it felt good to be able to catch that before exposing it to the public.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#final-thoughts" id="final-thoughts"&gt;&lt;/a&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;All in all it was a great project to dive into ClojureScript as I had a lot of fun and learned a lot while assembling this project together. What most excites me is what people will build with it once it&amp;rsquo;s out there, I see a lot of possibilities.&lt;/p&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="announcement"></category><category term="clojure"></category><category term="clojurescript"></category></entry><entry><id>urn:uuid:e46eaeb3-d5d5-4fc8-ba4d-de37cf869a07</id><title>How do you finish big side projects?</title><link href="https://eccentric-j.com/blog/4-completing-side-projects-in-2019.html" type="text/html" title="How do you finish big side projects?" rel="alternate"></link><published>2019-02-01T05:27:00Z</published><updated>2019-02-01T05:43:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/4-completing-side-projects-in-2019.html">&lt;h1&gt;&lt;a href="#2018-in-review" id="2018-in-review"&gt;&lt;/a&gt;2018 in Review&lt;/h1&gt;
&lt;p&gt;Every year since discovering &lt;a href="https://www.pinterest.com/bulletjournal/"&gt;bullet journaling&lt;/a&gt; I like to reflect on how I spent my time. In 2018 there has been noticeable improvement: I&amp;rsquo;ve been sleeping more, working closer to 40 hours a week, and more consistency with my schedule. There is however one major problem: I did not complete a single major side project!&lt;/p&gt;
&lt;h2&gt;&lt;a href="#how-did-i-not-complete-a-single-major-side-project-in-2018" id="how-did-i-not-complete-a-single-major-side-project-in-2018"&gt;&lt;/a&gt;How did I not complete a single major side project in 2018?&lt;/h2&gt;
&lt;p&gt;It comes down to my work habits. Looking at my how I spent my time I have two modes: Sprinting towards a finish line at a ridiculous pace or sloth mode, criminally chilling between projects. I did finish some smaller side projects, ones that could be sprinted through in a few late nights and a weekend. The problem appears to be a cycle I&amp;rsquo;ve created: Sprint through a small project, sloth it up until I recover and move on to the next project to start the cycle again. Now how do I fix it?&lt;/p&gt;
&lt;h2&gt;&lt;a href="#how-do-you-manage-your-time-for-side-projects" id="how-do-you-manage-your-time-for-side-projects"&gt;&lt;/a&gt;How do you manage your time for side projects?&lt;/h2&gt;
&lt;p&gt;In researching a few articles, books, and a bit of discussion there are some simple steps to make 2019 the year of the side project:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Break down your projects into the tiniest goals. If you know a project is going to take months: compose it down into 20 minute tasks. Working on a month long project is terrifying; working on a small task for 20 minutes sounds like a good way to start or end the day.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Be consistent when you work on side projects. It‚Äôs much easier to plan your day when you know 10:30 to 11 am is your side project time.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Try to work a little bit on a side project many days in a row. Once the habit forms, it feels weird not to spend mornings on a side project. Once you stop it feels weird to resume working on a side project.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don&amp;rsquo;t sprint and exhaust yourself. Instead try working on side projects a little bit at a time from 20 minutes to an hour and half. That way you can keep the pace up for longer stretches of time without burning out or loosing interest.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ensure you are taking time for yourself or having designated time that can‚Äôt be spent on side projects. I have the tendency to get really into a project and missing out on sleep, eating, and relaxation to try and sprint through it until completion. I&amp;rsquo;m basically begging for death, while metal as fuck &#x1f918;, that is not really how I want to go out.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Accept the outcome and let it go. This is where I shoot myself in the foot the most, when the 20 minute timer comes up and I impulsively start the timer immediately again telling myself &amp;ldquo;I&amp;rsquo;ll be able to finish it this time.&amp;rdquo; Then again. Then again and oh look, 3 hours just passed by. The gym is closed, the heat at the office has been shut off, and I haven&amp;rsquo;t eaten for 6 hours. Instead you need to retrain your mind to accept the result, whether the task is finished or not you made progress. Do something else and come back to it at the appropriate time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href="#does-this-advice-actually-work" id="does-this-advice-actually-work"&gt;&lt;/a&gt;Does this advice actually work?&lt;/h2&gt;
&lt;p&gt;This blog is the proof that applying those practices did help me complete at least one project this year. I wasn&amp;rsquo;t perfect, there have been stretches where I overdid it but it was still more sustainable than any other project I tried to work on in 2018. Other project ideas even came up while working on this blog but I did my best to write them down so I can return to them later. I imagine with more practice using the above strategy I may improve further. Still though how do you stop when you are enjoying yourself the most?&lt;/p&gt;
&lt;h2&gt;&lt;a href="#how-do-you-stop-when-you-want-to-keep-going" id="how-do-you-stop-when-you-want-to-keep-going"&gt;&lt;/a&gt;How do you stop when you want to keep going?&lt;/h2&gt;
&lt;p&gt;My biggest issue is stopping myself when those 20 minutes are up. There were parts of this blog I really enjoyed working on and felt compelled to see features through so I kept working on them. The consequences of doing so are fairly minor but they will add up. It almost physically hurts to stop working on a task that seems reachable within a few minutes to an hour, I think there&amp;rsquo;s some latent fear that I will not be able to solve it later even though historically I do. I don&amp;rsquo;t have a great solution for this yet but after asking the community in the Clojure slack I got some good advice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Set a physical alarm somewhere you have to get up and stop. This way you can&amp;rsquo;t just keep working, you have to physically move to turn it off.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reward yourself for being disciplined. Go ahead, put in your 20 min then get a fancy hipster coffee. You earned it!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Switch gears to a more enjoyable activity. If your problem is that you are &amp;ldquo;hooked on fun&amp;rdquo; (as it was put in the channel) then watch a movie, play a game, go on a date, eat, it just has to be something you will enjoy more.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When the timer is up, make sure you take a break or switch tasks. Treat it as an equally important part of the process as the task itself.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course I accidentally thought up of another side project in the form of a CLI tool that closes a tmux environment or other shell command after a time limit (likely killing any running development REPLs and servers). It still needs fleshing out but check out the wireframes:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://app.moqups.com/jayzawrotny/xG7CCH79a4/view"&gt;&lt;img src="/img/blog/4-side-project.png" alt="Side Project Wireframe" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#whats-next" id="whats-next"&gt;&lt;/a&gt;What&amp;rsquo;s next?&lt;/h2&gt;
&lt;p&gt;If you&amp;rsquo;re like me, we simply need to practice discipline. After more than a decade of working like this on personal projects I need to really put some time and effort into breaking those habits. There are three ways I&amp;rsquo;m going to approach this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Read books on building habits and discipline. Learning how to influence the brain‚Äôs decision making and reactions to stimuli will be very valuable in figuring out a more actionable plan.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Practice using the advice above to develop a better sense of pace and consistency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Track side project time in my bullet journal so I can observe improvements or patterns&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="experience"></category><category term="year-review"></category></entry><entry><id>urn:uuid:db151ec4-50b8-42f9-b20e-2153cb5d93f2</id><title>My Functional Programming Experience</title><link href="https://eccentric-j.com/blog/3-functional-programming-experience.html" type="text/html" title="My Functional Programming Experience" rel="alternate"></link><published>2019-01-29T00:31:00Z</published><updated>2019-01-29T18:52:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/3-functional-programming-experience.html">&lt;h1&gt;&lt;a href="#discovering-functional-programming" id="discovering-functional-programming"&gt;&lt;/a&gt;Discovering Functional Programming&lt;/h1&gt;
&lt;p&gt;I first encountered the phrase &amp;ldquo;Functional Programming&amp;rdquo; when learning about Redux for JS. My first question was &amp;ldquo;Isn‚Äôt all programming functional?&amp;rdquo; then I began researching it and got genuinely curious and found the motivation to study it further. Now about 2 years into it I can confirm it has deeply impacted how I think, work, and the trajectory of my career.&lt;/p&gt;
&lt;p&gt;When I started learning I was really in the weeds with OOP and wanted to abstract, generalize, and use all those fancy OOP patterns everywhere it made sense. The problem is whenever you create a custom class in most languages, it‚Äôs incompatible with everything else. Even in JS if I extend an array class it‚Äôs often treated as a separate type. So you often have to write more classes to make two classes talk to each other.&lt;/p&gt;
&lt;p&gt;In addition to those layers of abstraction for OOP I think there‚Äôs no upper limit to the complexity you can achieve and the vocabulary to describe OOP systems. Getters, setters, public, private, accessors, attributes, methods, virtual properties, constructor overrides, generics, magic methods, over loading, dependency injections, super, child,  inheritance, the list goes on I‚Äôm sure.&lt;/p&gt;
&lt;p&gt;With functional programming I find it has a pretty fixed amount of concepts that make up the methodology:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immutability&lt;/li&gt;
&lt;li&gt;Pure Functions&lt;/li&gt;
&lt;li&gt;Referential Transparency&lt;/li&gt;
&lt;li&gt;Composition&lt;/li&gt;
&lt;li&gt;Higher Order Functions&lt;/li&gt;
&lt;li&gt;Core Data Types&lt;/li&gt;
&lt;li&gt;Functors&lt;/li&gt;
&lt;li&gt;Monads&lt;/li&gt;
&lt;li&gt;Point Free&lt;/li&gt;
&lt;li&gt;Predicates&lt;/li&gt;
&lt;li&gt;Map, Filter, Reduce functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That may not be every concept but it is more than enough to build a strong sense of competency with the methodology.&lt;/p&gt;
&lt;p&gt;What‚Äôs great about learning those is that they all build on each other where as a lot of those OOP concepts are kind of parallel to each other where you can learn one without knowing the other.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#types-of-functional-programming-languages" id="types-of-functional-programming-languages"&gt;&lt;/a&gt;Types of Functional Programming Languages&lt;/h2&gt;
&lt;p&gt;There‚Äôs two major camps that functional programming falls into:&lt;/p&gt;
&lt;h3&gt;&lt;a href="#dynamic-languages" id="dynamic-languages"&gt;&lt;/a&gt;Dynamic Languages&lt;/h3&gt;
&lt;p&gt;Languages like Elixir and Clojure fall into this camp. They leverage dynamic types and focus on creating pipelines of functions to transform data. These languages also tend to be more side-effect friendly with looser restrictions but agreed upon naming conventions to denote when side effects happen. Generally these languages have a more practical nature to them focusing on getting work done.&lt;/p&gt;
&lt;h3&gt;&lt;a href="#static-languages" id="static-languages"&gt;&lt;/a&gt;Static Languages&lt;/h3&gt;
&lt;p&gt;Languages like Elm, F#, OCaml or Haskell fall into this camp. They emphasize type theory and other mathematic principles to leverage monads, or data types that represent computation builders to do most of the work. For instance the Array type in JS is a monad, it can be mapped to an array of other values, packed, and unpacked in itself. These languages are more strict about side effects often requiring them to be wrapped in a IO monad or similar system to separate out side-effect work from pure functions. While they can be used for practical work they often have an academic background and require more specification in determining the correctness of a program. For instance your program might not compile until you specify which types a function receives and returns.&lt;/p&gt;
&lt;h4&gt;&lt;a href="#other-languages" id="other-languages"&gt;&lt;/a&gt;Other Languages&lt;/h4&gt;
&lt;p&gt;Languages like JS, Ruby, and Python have some functional capabilities but I don‚Äôt consider them functional programming languages for the sake of this discussion. You can of course apply functional programming concepts to or within these languages.&lt;/p&gt;
&lt;h4&gt;&lt;a href="#comparison" id="comparison"&gt;&lt;/a&gt;Comparison&lt;/h4&gt;
&lt;p&gt;In so far I don‚Äôt strongly feel one camp is better than another, I‚Äôve just noticed that functional programming languages tend to lean to one side more than the other. While I‚Äôve chosen to focus on Clojure and Elixir for now, I‚Äôm also interested in learning and hearing about Haskell and Elm.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#does-functional-programming-make-you-a-better-programmer" id="does-functional-programming-make-you-a-better-programmer"&gt;&lt;/a&gt;Does functional programming make you a better programmer?&lt;/h2&gt;
&lt;p&gt;As far as improving as a programmer and engineer: I think putting in the time and effort to learning it will impact you for the better. I‚Äôve learned how to reduce complexity in the work I produce by composing larger systems from smaller functions that have very specific jobs, often aimed at expressing a domain-specific goal with pure functions as much as possible. This means fewer surprises for other programmers and stronger testability because testing pure functions like &lt;code&gt;add(1, 2)&lt;/code&gt; is much easier than testing classes, instances, and runtime app state like &lt;code&gt;this.router.handleRoute(window.location)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Instead of trying to make more complex data types like I did when strictly using OOP, I find myself mostly leaning on core types. Elixir is a great example; Elixir has hundreds of functions that can work on lists, maps, streams, and files. It has zero that work on that &lt;code&gt;Bid&lt;/code&gt; class we created at my day job.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#contributing-to-major-libraries" id="contributing-to-major-libraries"&gt;&lt;/a&gt;Contributing to Major Libraries&lt;/h2&gt;
&lt;p&gt;I‚Äôve found myself able to move faster with FP languages as well, I‚Äôm able to read the source of major libraries in languages like Clojure and make contributions despite only having about a year of experience with it.&lt;/p&gt;
&lt;p&gt;After using JS for a decade at this point there are many libraries I can barely make heads or tails of. They‚Äôre not bad, it‚Äôs just more difficult for me to understand the intention of the code and find room for improvement. Much of what‚Äôs out there is very side-effect driven and organized in larger chunks of business logic. For instance at work our &lt;code&gt;Bid&lt;/code&gt; class has methods like &lt;code&gt;accept&lt;/code&gt; which updates db state of several models, sends several emails to clients and partners, and populates another dependent model representing proposal data.  It feels like a lot but I‚Äôm unsure what the purpose of the method actually is.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#modeling-and-universal-principles" id="modeling-and-universal-principles"&gt;&lt;/a&gt;Modeling and Universal Principles&lt;/h2&gt;
&lt;p&gt;Lastly, I like how you can model real-world domains in FP. It feels more intuitive to me and I think is easier to explain to other people outside of the tech industry. &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;https://pragprog.com/book/swdddf/domain-modeling-made-functional&lt;/a&gt; is a great book on that topic and raises a good point that OOP does miss the mark in a lot of places, especially when you inevitably need classes like BidManager or PageFactory that don‚Äôt really map to anything in the domain.&lt;/p&gt;
&lt;p&gt;My favorite part about learning FP is how universal those principles are, I can apply them to Elixir, Clojure, Python, Ruby, PHP, JS, and I‚Äôm sure even more languages out there. Transitioning between functional programming languages feels like it‚Äôs just a matter of learning the syntax.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#visualizing-functional-programming" id="visualizing-functional-programming"&gt;&lt;/a&gt;Visualizing Functional Programming&lt;/h2&gt;
&lt;p&gt;A metaphor I really like to use is the Lego Great-Ball-Contraptions:&lt;br /&gt;
&lt;iframe
width="560"
height="315"
src="https://www.youtube.com/embed/Kp62YVtejiY"
frameborder="0"
allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;You have many different machines (functions) that operate on balls (common data types). In OOP the equivalent would be wrapping each ball in a new container so another machine can work with it then either unwrapping it or wrapping another container over the ball‚Äôs container for the next machine.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#oop-is-not-evil-but-what-we-have-done-with-it-could-be" id="oop-is-not-evil-but-what-we-have-done-with-it-could-be"&gt;&lt;/a&gt;OOP is not evil but what we have done with it could be&lt;/h2&gt;
&lt;p&gt;For the record I don‚Äôt despise OOP or think FP itself is what lead to my improvement, it‚Äôs more that I gained a new way of thinking and solving problems. I think there are contexts where OOP is the right choice (especially game programming) but there‚Äôs a lot of places where we reach for OOP or imperative programming that could be better tackled with a FP or FP-inspired approach.&lt;/p&gt;
&lt;blockquote class="disclaimer"&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: Originally my response to a reddit question:&lt;br /&gt;
&lt;a href="https://www.reddit.com/r/elixir/comments/ac7m4t/is_it_true_that_by_learning_functional_language/"&gt;Is it true that learning functional programming makes you a better programmer?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="clojure"></category><category term="elixir"></category><category term="experience"></category></entry><entry><id>urn:uuid:a811549b-242e-46dc-8813-27c9d20e5a9d</id><title>Site Launch &#x1f389;</title><link href="https://eccentric-j.com/blog/1-site-launch.html" type="text/html" title="Site Launch &#x1f389;" rel="alternate"></link><published>2019-01-25T23:00:00Z</published><updated>2019-01-29T19:05:00Z</updated><content type="html" xml:base="https://eccentric-j.com/blog/1-site-launch.html">&lt;h1&gt;&lt;a href="#why-even-make-a-blog-in-2019" id="why-even-make-a-blog-in-2019"&gt;&lt;/a&gt;Why even make a blog in 2019?&lt;/h1&gt;
&lt;p&gt;Likely lost in the void, I know, but I want to share some thoughts on functional programming and professional software engineering that mean a lot to me. Kind reddit commenters have &lt;a href="https://www.reddit.com/r/elixir/comments/ac7m4t/is_it_true_that_by_learning_functional_language/ed7qaqz/"&gt;unexpectedly&lt;/a&gt; &lt;a href="https://www.reddit.com/r/Clojure/comments/9ycubu/is_learning_clojure_a_good_idea_for_me/ea1b42n/"&gt;encouraged&lt;/a&gt; me to publish some of my meatier posts in functional programming subreddits. Now I have a place to publish them to.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#what-will-this-blog-cover" id="what-will-this-blog-cover"&gt;&lt;/a&gt;What will this blog cover?&lt;/h1&gt;
&lt;p&gt;This blog covers functional programming topics in languages like Clojure and ClojureScript. I may cover JavaScript, Elixir, Haskell, and Elm, but I intend to focus on Clojure and ClojureScript more since I enjoy working with them the most.&lt;/p&gt;
&lt;p&gt;I will also publish announcements of upcoming projects, tutorials\learning resources, open-ended ideas, and opinions on professional practices.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#what-platform-should-i-use" id="what-platform-should-i-use"&gt;&lt;/a&gt;What platform should I use?&lt;/h1&gt;
&lt;p&gt;This took a long time to decide. Wanting to tryout a &lt;a href="https://jamstack.org/"&gt;JAMstack&lt;/a&gt; a statically generated site felt the most enticing. Hugo and Jekyll seem really nice but I know I would be more motivated to keep working on it if it were in Clojure.  For building the static files I chose &lt;a href="https://perun.io/"&gt;https://perun.io/&lt;/a&gt; which is based on &lt;a href="https://github.com/boot-clj"&gt;Boot&lt;/a&gt; build tasks. I really like the concept of composing small tasks together to form larger bodies of functionality so it felt like a natural fit. Development moved fast and I am happy with the result so far. Now I have this powerful framework I can keep improving over time without investing too much time to bring ideas to life.&lt;/p&gt;
&lt;p&gt;For example the production build pipeline looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-clj"&gt;(deftask build
  &amp;quot;Build the blog source and output to target/public&amp;quot;
  [e build-env BUILD-ENV kw    &amp;quot;Environment keyword like :dev or :production&amp;quot;]
  (let [prod? (= build-env :prod)]
   (pipeline
     (generate-site :prod? prod?)
     (seo-files prod?)
     (cljs :ids [&amp;quot;prod&amp;quot;])
     (sass :output-style :compressed :source-map false)
     (clean :exclude [#&amp;quot;.git&amp;quot;])
     (target :no-clean true)
     (notify))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The rest of the source is available at &lt;a class="brand fa-github" href="https://github.com/eccentric-j/idle-parens"&gt;eccentric-j/idle-parens&lt;/a&gt; if you are the slightest bit curious how it all came together.&lt;/p&gt;
&lt;h1&gt;&lt;a href="#are-you-really-eccentric" id="are-you-really-eccentric"&gt;&lt;/a&gt;Are you really &lt;em&gt;eccentric&lt;/em&gt;?&lt;/h1&gt;
&lt;p&gt;No. Probably not. It felt like a nice word to embody my awkwardness along with my love of programming, cats, black\death metal, skulls, and occult imagery. While I‚Äôm more of a straight arrow than someone riding the line between the accepted norms and taboos of society I can dream can‚Äôt I? Who uses the internet to face the realities of who they actually are? That‚Äôs madness! &#x1f608;&lt;/p&gt;
</content><author><name>Eccentric J</name><email>jayzawrotny@gmail.com</email></author><category term="blog"></category><category term="projects"></category></entry></feed>